/**
 * Generate Markdown style guides from extracted styles
 */

import type { ExtractedStyles, StyleGuide } from "../types.js";

/**
 * Generates a Markdown style guide from extracted styles
 */
export function generateStyleGuideFromStyles(styles: ExtractedStyles): string {
  const lines: string[] = [];

  lines.push("# UI Style Guide");
  lines.push("");
  lines.push(
    "> Auto-generated by UILint. Edit this file to define your design system."
  );
  lines.push("");

  // Colors section
  lines.push("## Colors");
  lines.push("");
  const sortedColors = [...styles.colors.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);

  if (sortedColors.length > 0) {
    const colorNames = [
      "Primary",
      "Secondary",
      "Accent",
      "Background",
      "Text",
      "Muted",
      "Border",
      "Success",
      "Warning",
      "Error",
    ];
    sortedColors.forEach(([color, count], index) => {
      const name = colorNames[index] || `Color ${index + 1}`;
      lines.push(`- **${name}**: ${color} (${count} occurrences)`);
    });
  } else {
    lines.push("- No colors detected");
  }
  lines.push("");

  // Typography section
  lines.push("## Typography");
  lines.push("");

  // Font families
  const sortedFontFamilies = [...styles.fontFamilies.entries()].sort(
    (a, b) => b[1] - a[1]
  );

  if (sortedFontFamilies.length > 0) {
    lines.push(`- **Font Family**: ${sortedFontFamilies[0][0]}`);
  }

  // Font sizes
  const sortedFontSizes = [...styles.fontSizes.entries()].sort(
    (a, b) => parseFloat(a[0]) - parseFloat(b[0])
  );

  if (sortedFontSizes.length > 0) {
    const sizes = sortedFontSizes.map(([size]) => size).join(", ");
    lines.push(`- **Font Sizes**: ${sizes}`);
  }

  // Font weights
  const sortedFontWeights = [...styles.fontWeights.entries()].sort(
    (a, b) => parseInt(a[0]) - parseInt(b[0])
  );

  if (sortedFontWeights.length > 0) {
    const weights = sortedFontWeights.map(([weight]) => weight).join(", ");
    lines.push(`- **Font Weights**: ${weights}`);
  }
  lines.push("");

  // Spacing section
  lines.push("## Spacing");
  lines.push("");

  const sortedSpacing = [...styles.spacing.entries()]
    .filter(([value]) => value.endsWith("px"))
    .sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));

  if (sortedSpacing.length > 0) {
    // Try to detect base unit
    const spacingValues = sortedSpacing.map(([value]) => parseFloat(value));
    const gcd = findGCD(spacingValues.filter((v) => v > 0));

    if (gcd >= 4) {
      lines.push(`- **Base unit**: ${gcd}px`);
    }

    const uniqueSpacing = [...new Set(sortedSpacing.map(([v]) => v))].slice(
      0,
      8
    );
    lines.push(`- **Common values**: ${uniqueSpacing.join(", ")}`);
  } else {
    lines.push("- No spacing values detected");
  }
  lines.push("");

  // Border radius section
  lines.push("## Border Radius");
  lines.push("");

  const sortedBorderRadius = [...styles.borderRadius.entries()]
    .filter(([value]) => value !== "0px")
    .sort((a, b) => b[1] - a[1]);

  if (sortedBorderRadius.length > 0) {
    sortedBorderRadius.slice(0, 5).forEach(([value, count]) => {
      lines.push(`- ${value} (${count} occurrences)`);
    });
  } else {
    lines.push("- No border radius values detected");
  }
  lines.push("");

  // Components section (placeholder)
  lines.push("## Components");
  lines.push("");
  lines.push("- **Buttons**: Define button styles here");
  lines.push("- **Cards**: Define card styles here");
  lines.push("- **Inputs**: Define input styles here");
  lines.push("");

  return lines.join("\n");
}

/**
 * Finds the greatest common divisor of an array of numbers
 */
function findGCD(numbers: number[]): number {
  if (numbers.length === 0) return 0;
  if (numbers.length === 1) return numbers[0];

  const gcd = (a: number, b: number): number => {
    a = Math.abs(Math.round(a));
    b = Math.abs(Math.round(b));
    while (b) {
      const t = b;
      b = a % b;
      a = t;
    }
    return a;
  };

  return numbers.reduce((acc, n) => gcd(acc, n));
}

/**
 * Converts a StyleGuide object back to Markdown
 */
export function styleGuideToMarkdown(guide: StyleGuide): string {
  const lines: string[] = [];

  lines.push("# UI Style Guide");
  lines.push("");

  // Colors
  lines.push("## Colors");
  guide.colors.forEach((color) => {
    const usage = color.usage ? ` (${color.usage})` : "";
    lines.push(`- **${color.name}**: ${color.value}${usage}`);
  });
  lines.push("");

  // Typography
  lines.push("## Typography");
  guide.typography.forEach((typo) => {
    const props: string[] = [];
    if (typo.fontFamily) props.push(`font-family: "${typo.fontFamily}"`);
    if (typo.fontSize) props.push(`font-size: ${typo.fontSize}`);
    if (typo.fontWeight) props.push(`font-weight: ${typo.fontWeight}`);
    if (typo.lineHeight) props.push(`line-height: ${typo.lineHeight}`);
    lines.push(`- **${typo.element}**: ${props.join(", ")}`);
  });
  lines.push("");

  // Spacing
  lines.push("## Spacing");
  guide.spacing.forEach((space) => {
    lines.push(`- **${space.name}**: ${space.value}`);
  });
  lines.push("");

  // Components
  lines.push("## Components");
  guide.components.forEach((comp) => {
    lines.push(`- **${comp.name}**: ${comp.styles.join(", ")}`);
  });

  return lines.join("\n");
}
