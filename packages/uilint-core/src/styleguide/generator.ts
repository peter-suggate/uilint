/**
 * Generate Markdown style guides from extracted styles
 */

import type {
  ExtractedStyles,
  StyleGuide,
  TailwindThemeTokens,
} from "../types.js";
import {
  extractClassTokensFromHtml,
  topEntries,
} from "../tailwind/class-tokens.js";

/**
 * Generates a Markdown style guide from extracted styles
 */
export interface GenerateStyleGuideOptions {
  /**
   * Optional HTML/TSX-ish string used to extract utility classes (Tailwind etc).
   */
  html?: string;
  /**
   * Optional Tailwind theme tokens (typically from tailwind.config.*).
   */
  tailwindTheme?: TailwindThemeTokens | null;
}

export function generateStyleGuideFromStyles(
  styles: ExtractedStyles,
  options: GenerateStyleGuideOptions = {}
): string {
  const lines: string[] = [];

  lines.push("# UI Style Guide");
  lines.push("");
  lines.push(
    "> Auto-generated by UILint. Edit this file to define your design system."
  );
  lines.push("");

  // Merge in any literal hex colors found in the input markup/code.
  // This is important when the input is TSX/JSX or Tailwind-heavy, where
  // computed styles (JSDOM) may be sparse or unavailable.
  const html = options.html || "";
  const mergedColors = new Map(styles.colors);
  if (html) {
    for (const m of html.matchAll(/#[A-Fa-f0-9]{6}\b/g)) {
      const hex = (m[0] || "").toUpperCase();
      if (!hex) continue;
      mergedColors.set(hex, (mergedColors.get(hex) || 0) + 1);
    }
  }

  // Colors section
  lines.push("## Colors");
  lines.push("");
  const sortedColors = [...mergedColors.entries()].sort((a, b) => b[1] - a[1]);

  if (sortedColors.length > 0) {
    const colorNames = [
      "Primary",
      "Secondary",
      "Accent",
      "Background",
      "Text",
      "Muted",
      "Border",
      "Success",
      "Warning",
      "Error",
    ];
    sortedColors.forEach(([color, count], index) => {
      const name = colorNames[index] || `Color ${index + 1}`;
      lines.push(`- **${name}**: ${color} (${count} occurrences)`);
    });
  } else {
    lines.push("- No colors detected");
  }
  lines.push("");

  // Typography section
  lines.push("## Typography");
  lines.push("");

  // Font families
  const sortedFontFamilies = [...styles.fontFamilies.entries()].sort(
    (a, b) => b[1] - a[1]
  );

  if (sortedFontFamilies.length > 0) {
    lines.push(`- **Font Family**: ${sortedFontFamilies[0][0]}`);
  }

  // Font sizes
  const sortedFontSizes = [...styles.fontSizes.entries()].sort(
    (a, b) => parseFloat(a[0]) - parseFloat(b[0])
  );

  if (sortedFontSizes.length > 0) {
    const sizes = sortedFontSizes.map(([size]) => size).join(", ");
    lines.push(`- **Font Sizes**: ${sizes}`);
  }

  // Font weights
  const sortedFontWeights = [...styles.fontWeights.entries()].sort(
    (a, b) => parseInt(a[0]) - parseInt(b[0])
  );

  if (sortedFontWeights.length > 0) {
    const weights = sortedFontWeights.map(([weight]) => weight).join(", ");
    lines.push(`- **Font Weights**: ${weights}`);
  }
  lines.push("");

  // Spacing section
  lines.push("## Spacing");
  lines.push("");

  const sortedSpacing = [...styles.spacing.entries()]
    .filter(([value]) => value.endsWith("px"))
    .sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));

  if (sortedSpacing.length > 0) {
    // Try to detect base unit
    const spacingValues = sortedSpacing.map(([value]) => parseFloat(value));
    const gcd = findGCD(spacingValues.filter((v) => v > 0));

    if (gcd >= 4) {
      lines.push(`- **Base unit**: ${gcd}px`);
    }

    const uniqueSpacing = [...new Set(sortedSpacing.map(([v]) => v))].slice(
      0,
      8
    );
    lines.push(`- **Common values**: ${uniqueSpacing.join(", ")}`);
  } else {
    lines.push("- No spacing values detected");
  }
  lines.push("");

  // Border radius section
  lines.push("## Border Radius");
  lines.push("");

  const sortedBorderRadius = [...styles.borderRadius.entries()]
    .filter(([value]) => value !== "0px")
    .sort((a, b) => b[1] - a[1]);

  if (sortedBorderRadius.length > 0) {
    sortedBorderRadius.slice(0, 5).forEach(([value, count]) => {
      lines.push(`- ${value} (${count} occurrences)`);
    });
  } else {
    lines.push("- No border radius values detected");
  }
  lines.push("");

  // Components section (placeholder)
  lines.push("## Components");
  lines.push("");
  lines.push("- **Buttons**: Define button styles here");
  lines.push("- **Cards**: Define card styles here");
  lines.push("- **Inputs**: Define input styles here");
  lines.push("");

  // Tailwind / utility classes (optional)
  const classTokens = html ? extractClassTokensFromHtml(html) : null;
  const topUtilities = classTokens ? topEntries(classTokens.utilities, 50) : [];
  const topVariants = classTokens ? topEntries(classTokens.variants, 20) : [];
  const allUtilities = classTokens
    ? [...classTokens.utilities.entries()]
        .sort((a, b) => (b[1] - a[1] ? b[1] - a[1] : a[0].localeCompare(b[0])))
        .map(([token]) => token)
    : [];

  const theme = options.tailwindTheme;
  const themeColors = theme?.colors || [];
  const themeSpacingKeys = theme?.spacingKeys || [];
  const themeBorderRadiusKeys = theme?.borderRadiusKeys || [];
  const themeFontFamilyKeys = theme?.fontFamilyKeys || [];
  const themeFontSizeKeys = theme?.fontSizeKeys || [];

  const hasTailwindSection =
    topUtilities.length > 0 ||
    themeColors.length > 0 ||
    themeSpacingKeys.length > 0 ||
    themeBorderRadiusKeys.length > 0 ||
    themeFontFamilyKeys.length > 0 ||
    themeFontSizeKeys.length > 0;

  if (hasTailwindSection) {
    lines.push("## Tailwind");
    lines.push("");
    lines.push(
      "> Optional. Captures Tailwind/utility class conventions for validation and consistency."
    );
    lines.push("");

    if (topUtilities.length > 0) {
      const utilityList = topUtilities
        .slice(0, 25)
        .map((u) => `\`${u.token}\``)
        .join(", ");
      lines.push(`- **Observed utilities (top)**: ${utilityList}`);
    } else {
      lines.push("- **Observed utilities (top)**: (none detected)");
    }

    if (topVariants.length > 0) {
      const variantList = topVariants
        .slice(0, 12)
        .map((v) => `\`${v.token}\``)
        .join(", ");
      lines.push(`- **Common variants**: ${variantList}`);
    }

    if (theme) {
      lines.push(`- **Config path**: \`${theme.configPath}\``);
      if (themeColors.length > 0) {
        lines.push(
          `- **Theme colors (tokens)**: ${themeColors
            .slice(0, 25)
            .map((t) => `\`${t}\``)
            .join(", ")}${themeColors.length > 25 ? ", ..." : ""}`
        );
      } else {
        lines.push("- **Theme colors (tokens)**: (none specified in config)");
      }

      if (themeSpacingKeys.length > 0) {
        lines.push(
          `- **Theme spacing keys**: ${themeSpacingKeys
            .slice(0, 25)
            .map((k) => `\`${k}\``)
            .join(", ")}${themeSpacingKeys.length > 25 ? ", ..." : ""}`
        );
      }
    }

    // Machine-readable payload to make parsing/validation robust.
    const payload = {
      // IMPORTANT: include all observed utilities (not just "top N"), otherwise
      // init+validate on the same file can be inconsistent.
      allowedUtilities: allUtilities,
      allowAnyColor: !!theme && themeColors.length === 0, // avoid noisy warnings when config doesn't define colors
      allowStandardSpacing: !!theme && themeSpacingKeys.length === 0,
      themeTokens: theme
        ? {
            configPath: theme.configPath,
            colors: themeColors,
            spacingKeys: themeSpacingKeys,
            borderRadiusKeys: themeBorderRadiusKeys,
            fontFamilyKeys: themeFontFamilyKeys,
            fontSizeKeys: themeFontSizeKeys,
          }
        : null,
    };

    lines.push("");
    lines.push("```json");
    lines.push(JSON.stringify(payload, null, 2));
    lines.push("```");
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Finds the greatest common divisor of an array of numbers
 */
function findGCD(numbers: number[]): number {
  if (numbers.length === 0) return 0;
  if (numbers.length === 1) return numbers[0];

  const gcd = (a: number, b: number): number => {
    a = Math.abs(Math.round(a));
    b = Math.abs(Math.round(b));
    while (b) {
      const t = b;
      b = a % b;
      a = t;
    }
    return a;
  };

  return numbers.reduce((acc, n) => gcd(acc, n));
}

/**
 * Converts a StyleGuide object back to Markdown
 */
export function styleGuideToMarkdown(guide: StyleGuide): string {
  const lines: string[] = [];

  lines.push("# UI Style Guide");
  lines.push("");

  // Colors
  lines.push("## Colors");
  guide.colors.forEach((color) => {
    const usage = color.usage ? ` (${color.usage})` : "";
    lines.push(`- **${color.name}**: ${color.value}${usage}`);
  });
  lines.push("");

  // Typography
  lines.push("## Typography");
  guide.typography.forEach((typo) => {
    const props: string[] = [];
    if (typo.fontFamily) props.push(`font-family: "${typo.fontFamily}"`);
    if (typo.fontSize) props.push(`font-size: ${typo.fontSize}`);
    if (typo.fontWeight) props.push(`font-weight: ${typo.fontWeight}`);
    if (typo.lineHeight) props.push(`line-height: ${typo.lineHeight}`);
    lines.push(`- **${typo.element}**: ${props.join(", ")}`);
  });
  lines.push("");

  // Spacing
  lines.push("## Spacing");
  guide.spacing.forEach((space) => {
    lines.push(`- **${space.name}**: ${space.value}`);
  });
  lines.push("");

  // Components
  lines.push("## Components");
  guide.components.forEach((comp) => {
    lines.push(`- **${comp.name}**: ${comp.styles.join(", ")}`);
  });

  return lines.join("\n");
}
